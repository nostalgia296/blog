<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Lai</title><description>Yu</description><link>https://nostalgia296.github.io/</link><language>zh_CN</language><item><title>termux交叉编译windows的go程序</title><link>https://nostalgia296.github.io/blog/posts/%E5%9C%A8termux%E4%B8%AD%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91windows%E7%9A%84go%E7%A8%8B%E5%BA%8F/</link><guid isPermaLink="true">https://nostalgia296.github.io/blog/posts/%E5%9C%A8termux%E4%B8%AD%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91windows%E7%9A%84go%E7%A8%8B%E5%BA%8F/</guid><pubDate>Sat, 29 Nov 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;因为termux源里有&lt;code&gt;llvm-mingw&lt;/code&gt;,所以在&lt;code&gt;CGO&lt;/code&gt;（默认开启)开始的情况下，指定&lt;code&gt;CC&lt;/code&gt;路径为&lt;code&gt;llvm-mingw&lt;/code&gt;的特定架构的编译器，就可以交叉编译windows程序了。&lt;/p&gt;
&lt;p&gt;比如说我想要编译x86_64架构的windows程序:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GOOS=windows GOARCH=amd64 CC=x86_64-w64-mingw32-clang go build xxx.go
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>解除Touchgal这类网站的跳转限制的思路</title><link>https://nostalgia296.github.io/blog/posts/%E8%B7%B3%E8%BF%87touchgal%E8%BF%99%E7%B1%BB%E7%BD%91%E7%AB%99%E7%9A%84%E8%B7%B3%E8%BD%AC%E9%99%90%E5%88%B6/</link><guid isPermaLink="true">https://nostalgia296.github.io/blog/posts/%E8%B7%B3%E8%BF%87touchgal%E8%BF%99%E7%B1%BB%E7%BD%91%E7%AB%99%E7%9A%84%E8%B7%B3%E8%BD%AC%E9%99%90%E5%88%B6/</guid><pubDate>Fri, 28 Nov 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;解除Touchgal这类网站的跳转限制&lt;/h1&gt;
&lt;p&gt;Touchgal在从主站跳转到网盘链接的时候，会有5s的时长限制，于是想写一个油猴脚本来跳过，常规思路是直接截取跳转界面网址&lt;code&gt;redirect=&lt;/code&gt;后面的目标链接，但是对于&lt;code&gt;Touchgal&lt;/code&gt;这类网站来说弹到跳转界面时不会触发tampermonkey注入脚本。&lt;/p&gt;
&lt;p&gt;我的思路是重写&lt;code&gt;history.pushState&lt;/code&gt;和&lt;code&gt;history.replaceState&lt;/code&gt;,触发时，调用自动跳转方法。&lt;/p&gt;
&lt;h2&gt;代码实现:&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;// ==UserScript==
// @name         TouchGal 自动跳转
// @namespace    http://tampermonkey.net/
// @version      1.0
// @description  跳过5s等待
// @match        https://www.touchgal.us/*
// @grant        none
// @run-at       document-start
// ==/UserScript==

(function() {
    &apos;use strict&apos;;

    let lastUrl = location.href;

    //截取并跳转
    function autoRedirect() {
        const currentUrl = location.href;

        // 防止重复执行
        if (currentUrl === lastUrl) return;
        lastUrl = currentUrl;

        // 检查是否是重定向页面
        if (currentUrl.includes(&apos;/redirect?url=&apos;)) {
            // 截取 url= 后面的内容
            const targetUrl = getUrlParameter(&apos;url&apos;);

            if (targetUrl) {
                console.log(&apos;检测到重定向链接:&apos;, targetUrl);
                console.log(&apos;正在跳转...&apos;);

                // 执行跳转
                window.location.href = decodeURIComponent(targetUrl);
            } else {
                console.warn(&apos;未找到目标链接&apos;);
            }
        }
    }

    // 提取 URL 参数的函数
    function getUrlParameter(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
    }

    autoRedirect();
    // 保存原始方法
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;

    // 重写 pushState
    history.pushState = function() {
        originalPushState.apply(history, arguments);
        setTimeout(autoRedirect, 100);
    };

    // 重写 replaceState
    history.replaceState = function() {
        originalReplaceState.apply(history, arguments);
        setTimeout(autoRedirect, 100);
    };

    // 监听浏览器前进/后退
    window.addEventListener(&apos;popstate&apos;, function() {
        setTimeout(autoRedirect, 100);
    });

    window.addEventListener(&apos;hashchange&apos;, function() {
        setTimeout(autoRedirect, 100);
    });
})();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;github仓库&lt;/h2&gt;
&lt;p&gt;::github{repo=&quot;nostalgia296/backup&quot;}&lt;/p&gt;
</content:encoded></item><item><title>文本加解密</title><link>https://nostalgia296.github.io/blog/posts/%E6%96%87%E6%9C%AC%E5%8A%A0%E8%A7%A3%E5%AF%86/</link><guid isPermaLink="true">https://nostalgia296.github.io/blog/posts/%E6%96%87%E6%9C%AC%E5%8A%A0%E8%A7%A3%E5%AF%86/</guid><pubDate>Fri, 28 Nov 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;msbt.seku.su网站文本加解密的实现原理&lt;/h1&gt;
&lt;h2&gt;1. 核心思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;把 UTF-8 字节流拆成 &lt;strong&gt;高 4 位&lt;/strong&gt; 和 &lt;strong&gt;低 4 位&lt;/strong&gt;（每个字节 = 16 进制的高 + 低）。&lt;/li&gt;
&lt;li&gt;给 0–15 这 16 个数字各分配一个「语气词」：&lt;pre&gt;&lt;code&gt;0 齁  1 哦  2 噢  3 喔  4 咕  5 咿  6 嗯  7 啊
8 ～  9 哈  10 ！ 11 唔  12 哼  13 ❤  14 呃  15 呼
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;编码：高 4 位 → 取第 1 个词，低 4 位 → 取第 2 个词，拼起来。&lt;br /&gt;
解码：逆过程，先查词得数字，再 &lt;code&gt;(high &amp;lt;&amp;lt; 4) | low&lt;/code&gt; 还原字节，最后 &lt;code&gt;utf8.decode&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2&gt;2. 完整源码（基于dart）&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;import &apos;dart:convert&apos;;
import &apos;dart:io&apos;;

const List&amp;lt;String&amp;gt; _codebook = [
  &quot;齁&quot;, &quot;哦&quot;, &quot;噢&quot;, &quot;喔&quot;, &quot;咕&quot;, &quot;咿&quot;, &quot;嗯&quot;, &quot;啊&quot;,
  &quot;～&quot;, &quot;哈&quot;, &quot;！&quot;, &quot;唔&quot;, &quot;哼&quot;, &quot;❤&quot;, &quot;呃&quot;, &quot;呼&quot;,
];

/// 词 → 数字 的反向索引
late final Map&amp;lt;String, int&amp;gt; _map = Map.fromEntries(
  _codebook.indexed.map((e) =&amp;gt; MapEntry(e.$2, e.$1)),
);

/// 编码：任意字符串 → 齁哦噢…
String encode(String input) {
  final bytes = utf8.encode(input);
  final buf = StringBuffer();
  for (final b in bytes) {
    buf.write(_codebook[(b &amp;gt;&amp;gt; 4) &amp;amp; 0x0F]);
    buf.write(_codebook[b &amp;amp; 0x0F]);
  }
  return buf.toString();
}

/// 解码：齁哦噢… → 原字符串
String decode(String input) {
  if (input.length.isOdd) throw FormatException(&apos;长度必须为偶数&apos;);
  final runes = input.runes.toList();
  final bytes = &amp;lt;int&amp;gt;[];
  for (int i = 0; i &amp;lt; runes.length; i += 2) {
    final high = _map[String.fromCharCode(runes[i])];
    final low  = _map[String.fromCharCode(runes[i + 1])];
    if (high == null || low == null) {
      throw FormatException(&apos;包含非法字符&apos;);
    }
    bytes.add((high &amp;lt;&amp;lt; 4) | low);
  }
  try {
    return utf8.decode(bytes);
  } catch (_) {
    // 如果 UTF-8 非法，退化为 16 进制字符串
    return bytes.map((b) =&amp;gt; b.toRadixString(16).padLeft(2, &apos;0&apos;)).join();
  }
}

void main(List&amp;lt;String&amp;gt; args) {
  if (args.length != 2) {
    print(&apos;用法: dart run main.dart &amp;lt;en|de&amp;gt; &quot;文本&quot;&apos;);
    return;
  }
  final mode = args[0];
  final text = args[1];
  try {
    print(mode == &apos;en&apos; ? encode(text) : decode(text));
  } catch (e) {
    print(&apos;错误: $e&apos;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item></channel></rss>